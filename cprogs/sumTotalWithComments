	#sumTotal with comments by nerdusbirdus
	#dot operators taken out, code made my own with commenting 

## %bb.0 (start):
	pushq	%rbp                        ## pushes rbp value onto stack, creating new stackframe
	movq	%rsp, %rbp                  ## moves stack pointer value to base pointer, establishing start of new call stack
	jmp	LBB0_1                          ## Jump to beginning of inner loop
LBB0_1:                                 ## =>This Inner Loop Header: Depth=1  << this is a comment generated by GCC, weird!
	cmpl	$0, _count(%rip)            ## compare zero with the value in the instruction pointer which is the value for count
	jl	LBB0_3                          ## if count is less than 0 then we jump to LBB0_3 else continue 
## %bb.2 (adder loop):                  ##   in Loop: Header=BB0_1 Depth=1 << another GCC comment
	movl	_count(%rip), %eax          ## moves the value of count from %rip to lower 32 of %rax for a parameter value (does this mean an implicit load instruction since rip points to the data?)
	addl	_total(%rip), %eax          ## adds the value of total from %rip to the value of count (does this mean an implicit load instruction?)
	movl	%eax, _total(%rip)          ## moves value of total plus count from %eax to the location for _total (equivalent to sta total)
	movl	_count(%rip), %eax          ## moves count into eax (equivalent to lda count)
	addl	$-1, %eax                   ## adds -1 to count in eax, decrementing by 1
	movl	%eax, _count(%rip)          ## moves new value for count into location for count (sta count)
	jmp	LBB0_1                          ## jumps to beginning of loop to run again, until count is 0
LBB0_3:                                 ## executes when count is 0
	popq	%rbp                        ## pops base pointer off stack, adds bytes to shrink stack
	retq                                ## returns to the function that called it which in this case takes it to main 
_main:                                  ## @main << GCC wrote this, to make sure we know where main is I guess.
## %bb.0:                               ## begins main
	pushq	%rbp                        ## pushes a new stackframe onto memory because it is a new function
	movq	%rsp, %rbp                  ## moves stack pointer
	subq	$16, %rsp                   ## allocates space for the function on the stack frame, 16 bytes worth.
	movl	$0, -4(%rbp)                ## stores 0 4 bytes below base pointer
	callq	_start                      ## calls start function, which runs until count is 0 and LBB0_3 returns the values from it here to main
	movl	_total(%rip), %esi          ## moves the value from total into %esi which is lower 32 of %rsi which is used to pass 2nd argument to functions
	leaq	L_.str(%rip), %rdi          ## load effective address of the string literal, puts that in %rdi for first argument, it will be printed in printf
	movb	$0, %al                     ## moves 0 into lower 8 bytes of %rax and I do not know why this happens and I have seen it in other printf functions
	callq	_printf                     ## calls printf to print the string in %rdi and the arg in %esi for outputting total
	xorl	%eax, %eax                  ## clears out %eax to 0 by Xor-ing it with itself
	addq	$16, %rsp                   ## adds 16 to stack pointer, shrinking stack
	popq	%rbp                        ## pops base pointer off stack frame
	retq                                ## return statement which in this case ends the function 
                                        ## -- End function << another GCC comment
	